# 併發相關 原子操作

今天來介紹原子操作，簡單的說原子操作就是這個操作要馬完全完成，要嘛都沒完成，下面就來看看C++中的原子變數

## atomic_T

`atomic`實際上支援大多數基本類型(int, char, float, bool等)，然後每個`atomic`都會有以下函數

### 建構函數

因為原子變數本身是原子特性，所以原子變數是不能複製或移動的。

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <atomic>

using namespace std;

int main(int argc, char const *argv[])
{
    atomic<int> aInt(0);
    // atomic<int> aInt2(move(aInt));  atomic (const atomic&) = delete;
    atomic<int> aInt3 = 0; // operator= 是可以的

    return 0;
}
```

### is_lock_free函數

`is_lock_free`是來確認當前`atomic`對象是否支持無鎖操作，無鎖操作在day30會提到，主要原子操作的關鍵是在同步化中取代用互斥鎖`mutex`的操作，期望是提升性能。

```cpp
int main(int argc, char const *argv[])
{
    atomic<int> aInt(0);
    cout << "atomic<int> is lock free :" << aInt.is_lock_free() << endl;;

    return 0;
}
```

### memory_order

C++中的記憶體排序共有六種，主要是用於控制記憶體的存取順序，分為以下六種

| 類型                 | 名稱          | 行為                                                           | 場景                                                              |
| -------------------- | ------------- | -------------------------------------------------------------- | ----------------------------------------------------------------- |
| memory_order_relaxed | 寬鬆排序      | 不提供同步，也不限制記憶體順序。只保證原子性。                 | 常用於統計計數器、非同步事件紀錄器等不需要同步的資料更新          |
| memory_order_acquire | 取得排序      | 讀操作之後的操作不能被重排序這個讀之前。                       | 鎖的讀取、條件判斷，用於同步某資源是否可用                        |
| memory_order_release | 釋放排序      | 寫操作之前的操作不能被重排序這個寫之後。                       | 解鎖、資源狀態標記為完成。通常與acquire 搭配                      |
| memory_order_acq_rel | 取得+釋放排序 | 同時具備acquire和release行為，屬於RMW操作(Read-Modify-Write)。 | 鎖的操作修改                                                      |
| memory_order_seq_cst | 順序一致      | 預設值，跨執行緒可觀察的單一總序。                             | 預設選項，對性能沒有特別要求，邏輯相對簡單的場景                  |
| memory_order_consume | 消費排序      | 資料相依關係下的讀取順序。                                     | 不建議使用，因為編譯器尚未支援，目前功能等同 memory_order_acquire |

總的來說，性能上的順序為 寬鬆排序(memory_order_relaxed) > 獲取 - 釋放排序(memory_order_acquire、memory_order_release、memory_order_acq_rel、memory_order_consume) > 順序一致 (memory_order_seq_cst)，因為從同步的角度來看，越高的一致性，代表越多的同步，處理器之間就可能進行大量的同步操作。

#### memory_order_seq_cst

順序一致是最直觀的排序，因為它會要求所以執行緒之間都要全域同步變數的狀態，但相對的代價就是多處理器之間會需要大規模的通訊行為。

```cpp
#include <thread>
#include <atomic>
#include <assert.h>

using namespace std;

atomic<bool> x, y;
atomic<int> z;

void write_x()
{
    x.store(true, memory_order_seq_cst);
}

void write_y()
{
    y.store(true, memory_order_seq_cst);
}

void read_x_then_y()
{
    while (!x.load(memory_order_seq_cst))
        ;
    if (y.load(memory_order_seq_cst))
        ++z;
}

void read_y_then_x()
{
    while (!y.load(memory_order_seq_cst))
        ;
    if (x.load(memory_order_seq_cst))
        ++z;
}

int main(int argc, char const *argv[])
{
    x = false;
    y = false;
    z = 0;
    thread a(write_x);
    thread b(write_y);
    thread c(read_x_then_y);
    thread d(read_y_then_x);
    a.join();
    b.join();
    c.join();
    d.join();
    assert(z.load() != 0);

    return 0;
}
```

#### memory_order_relaxed

當我們使用非順序排序(除了 `memory_order_seq_cst` 以外的排序)，代表`執行緒不必同意事件的排序`，因為編譯器可以重新排序指令，以及如果沒有明顯的排序限制，代表執行相同程式碼的執行緒，可以不同意這些事物的順序，下面代碼中的 `x.store` 跟 `y.store`，實際上順序可能不一定照代碼寫的順序，另外不同執行緒觀察到的順序也是不被保證的，這導致可能產生 `y == true` 但 `x == false`的現象，不過 x86 的處裡器會保證跨核心觀察到同一執行緒的store依程式順序，所以下面的代碼要用 ARM 之類的處裡器才比較有可能遇到 `z == 0`。

```cpp
#include <thread>
#include <atomic>
#include <assert.h>

using namespace std;

atomic<bool> x, y;
atomic<int> z;

void write_x_then_y()
{
    x.store(true, memory_order_relaxed);
    y.store(true, memory_order_relaxed);    
}

void read_y_then_x()
{
    while (!y.load(memory_order_relaxed))
        ;
    if (x.load(memory_order_relaxed))
        ++z;
}

int main(int argc, char const *argv[])
{
    x = false;
    y = false;
    z = 0;
    thread a(write_x_then_y);
    thread b(read_y_then_x);
    a.join();
    b.join();
    assert(z.load() != 0);

    return 0;
}
```

### memory_order_acquire_release

`memory_order_acquire`, `memory_order_release`, `memory_order_acq_rel` 排序是從 `memory_order_relaxed` 上發展而來的，代表這些排序是有一定的操作排序，所以會有同步的行為。同步是在執行釋放的執行緒與執行獲取的執行緒之間成對進行。也就是說不同執行緒是可以看到不同的操作排序，只是不同於`memory_order_relaxed`排序，這些獲取-釋放排序能夠對排序進行限制。

以下面的代碼為範例，`assert`是會被觸發的(`z == 0`)，因為`x.store`跟`y.store`是由不同執行緒寫入的，所以`x.load`跟`y.load`是有可能讀到false，也就是說`釋放到獲取的排序在每種情況下都不會對其他執行緒的操作產生影響`。

```cpp
#include <thread>
#include <atomic>
#include <assert.h>

using namespace std;

atomic<bool> x, y;
atomic<int> z;

void write_x()
{
    x.store(true, memory_order_release);
}

void write_y()
{
    y.store(true, memory_order_release);
}

void read_x_then_y()
{
    while (!x.load(memory_order_acquire))
        ;
    if (y.load(memory_order_acquire))
        ++z;
}

void read_y_then_x()
{
    while (!y.load(memory_order_acquire))
        ;
    if (x.load(memory_order_acquire))
        ++z;
}

int main(int argc, char const *argv[])
{
    x = false;
    y = false;
    z = 0;
    thread a(write_x);
    thread b(write_y);
    thread c(read_x_then_y);
    thread d(read_y_then_x);
    a.join();
    b.join();
    c.join();
    d.join();
    assert(z.load() != 0);

    return 0;
}
```

所以為了要擁有獲取、釋放的好處(比順序一致的排序還高的性能)，又要避免其可能帶有的操作排序問題，實際上的做法可以參考下方的代碼。透過遵循事前發生關係的約束(如在相同的執行緒內)，我們讓`y.store`加上釋放排序，另一邊`y.load`加上獲取排序，以確保y在while中能取到true(若沒有while，是可能讀到false，所以才會透過while，形成一個自旋迴圈來確保拿到true)，最後讓`x.load`能確保拿到true。

```cpp
#include <thread>
#include <atomic>
#include <assert.h>

using namespace std;

atomic<bool> x, y;
atomic<int> z;

void write_x_then_y()
{
    x.store(true, memory_order_relaxed);
    y.store(true, memory_order_release);    
}

void read_y_then_x()
{
    while (!y.load(memory_order_acquire))
        ;
    if (x.load(memory_order_relaxed))
        ++z;
}

int main(int argc, char const *argv[])
{
    x = false;
    y = false;
    z = 0;
    thread a(write_x_then_y);
    thread b(read_y_then_x);
    a.join();
    b.join();
    assert(z.load() != 0);

    return 0;
}
```

### atomic_thread_fence

柵欄(fence)是能在不修改任何資料的情況下強制執行記憶體排序約束的操作。通常是與`memory_relaxed`排序的原子操作一起使用，以提供有約束的排序。這邊柵欄的作法，實際上等同於上面的將`y.store`加上release，將`y.load`加上acquire，結果就是確保看到y為true的執行緒，也看到x為true，從而保證不會觸發`z == 0`的assert。

```cpp
#include <thread>
#include <atomic>
#include <assert.h>

using namespace std;

atomic<bool> x, y;
atomic<int> z;

void write_x_then_y()
{
    x.store(true, memory_order_relaxed);
    atomic_thread_fence(memory_order_release);
    y.store(true, memory_order_relaxed);    
}

void read_y_then_x()
{
    while (!y.load(memory_order_relaxed))
    ;
    atomic_thread_fence(memory_order_acquire);
    if (x.load(memory_order_relaxed))
        ++z;
}

int main(int argc, char const *argv[])
{
    x = false;
    y = false;
    z = 0;
    thread a(write_x_then_y);
    thread b(read_y_then_x);
    a.join();
    b.join();
    assert(z.load() != 0);

    return 0;
}
```

## 參考

[C++ 併發處理實戰](https://www.tenlong.com.tw/products/9786263240032?list_name=srh)
